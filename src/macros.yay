<?php

$(macro) {
    declare {
        $(repeat(either(
            chain(
                optional(buffer('static') as static),
                optional(buffer('inline') as inline),
                token(T_FUNCTION),
                llvmidentifier() as name,
                token('('),
                optional(ls(
                    chain(optional(T_CONST as const), ctype() as type),
                    token(',')
                ) as params),
                token(')'),
                token(':'),
                ctype() as returnType,
                token(';')
            ) as func,
            chain(
                optional(buffer('static') as vararg_static),
                optional(buffer('inline') as vararg_inline),
                token(T_FUNCTION),
                llvmidentifier() as vararg_name,
                token('('),
                optional(chain(ls(
                    chain(optional(T_CONST as vararg_const), ctype() as vararg_type),
                    token(',')
                ) as vararg_params, token(',')) as vararg_outer_params),
                token(T_ELLIPSIS),
                token(')'),
                token(':'),
                ctype() as vararg_returnType,
                token(';')
            ) as vararg_func,
            chain(
                buffer('struct'),
                llvmidentifier() as struct_name,
                token('{'),
                repeat(
                    chain(ctype() as field_type, T_VARIABLE as field_name, token(';'))
                ) as fields,
                token('}'),
                token(';')
            ) as struct
        )) as decls)
    }
} >> {
    $(decls ... {
        $(func ? ... {
            $fntype = $this->context->context->functionType(
                $this->context->getTypeFromString($$(stringify($(returnType)))),
                false $(params ? { , })
                $(params ... ( , ) {
                    $this->context->getTypeFromString($$(stringify($(type))))
                })
            );
            $fn = $this->context->module->addFunction($$(stringify($(name))), $fntype);
            $(inline ? ... {
                $fn->addAttributeAtIndex(PHPLLVM\Attribute::INDEX_FUNCTION, $this->context->attributes['alwaysinline']);
            })
            $(params ... i {
                $(const ? {
                    $fn->addAttributeAtIndex($(i) + 1, $this->context->attributes['readonly'], 0);
                    $fn->addAttributeAtIndex($(i) + 1, $this->context->attributes['nocapture'], 0);
                })
            })
            $this->context->registerFunction($$(stringify($(name))), $fn);
        })

        $(vararg_func ? ... {
            $fntype = $this->context->context->functionType(
                $this->context->getTypeFromString($$(stringify($(vararg_returnType)))),
                true $(vararg_outer_params ... { $(vararg_params ? { , }) })
                $(vararg_outer_params ... { $(vararg_params ... ( , ) {
                    $this->context->getTypeFromString($$(stringify($(vararg_type))))
                }) })
            );
            $fn = $this->context->module->addFunction($$(stringify($(vararg_name))), $fntype);
            $(vararg_inline ? ... {
                $fn->addAttributeAtIndex(PHPLLVM\Attribute::INDEX_FUNCTION, $this->context->attributes['alwaysinline']);
            })
            $(vararg_outer_params ... { $(vararg_params ... i {
                $(vararg_const ? {
                    $fn->addAttributeAtIndex($(i) + 1, $this->context->attributes['readonly'], 0);
                    $fn->addAttributeAtIndex($(i) + 1, $this->context->attributes['nocapture'], 0);
                })
            }) })
            $this->context->registerFunction($$(stringify($(vararg_name))), $fn);
        })

        $(struct ? ... {
            $struct = $this->context->context->namedStructType($$(stringify($(struct_name))));
            $struct->setBody(
                false $(fields ? { , }) // packed
                $(fields ... ( , ) {
                $this->context->getTypeFromString($$(stringify($(field_type))))
                })
            );
            $this->context->registerType($$(stringify($(struct_name))), $struct);
            $this->context->registerType($$(stringify($(struct_name))) . '*', $struct->pointerType(0));
            $this->context->registerType($$(stringify($(struct_name))) . '**', $struct->pointerType(0)->pointerType(0));
            $this->context->structFieldMap[$$(stringify($(struct_name)))] = [
                $(fields ... (, ) i {
                    $$(stringify($$(unvar($(field_name))))) => $(i)
                })
            ];
        })
    })
}

$(macro) {
    compile {
        function $(llvmidentifier() as name) ($(ls(
            T_VARIABLE as param,
            token(',')
        ) as params)) {
            $(layer() as stmts)
        }
    }
} >> {
    $fn = $this->context->lookupFunction($$(stringify($(name))));
    $block = $fn->appendBasicBlock('main');
    $this->context->builder->positionAtEnd($block);
    $(params ... i {
        $(param) = $fn->getParam($(i));
    })
    compile {
        $(stmts)
    }
    $this->context->builder->clearInsertionPosition();
}

// First, expand statements
$(macro :unsafe :recursive) {
    $(optional(buffer('unsigned')) as unsigned) compile {
        $(repeat(either(
            chain(T_VARIABLE as result, token('='), either(
                chain(T_VARIABLE as nullcheck_var, token(T_IS_EQUAL), buffer('null')) as nullcheck,
                chain(T_CONSTANT_ENCAPSED_STRING as conststr_value) as conststr,
                chain(token('('), T_STRING as cast_type, token(')'), T_VARIABLE as cast_value) as cast,
                chain(token('('), T_STRING as constcast_type, token(')'), expression() as constcast_value) as constcast,
                chain(token('('), ctype() as ptrcast_type, token(')'), T_VARIABLE as ptrcast_value) as ptrcast,
                chain(T_VARIABLE as field_deref_var, token(T_OBJECT_OPERATOR), label() as field_deref_field) as field_deref,
                chain(token('&'), T_VARIABLE as field_deref_ref_var, token(T_OBJECT_OPERATOR), label() as field_deref_ref_field) as field_deref_ref,
                chain(T_VARIABLE as field_extract_var, token('.'), label() as field_extract_field) as field_extract,
                chain(token('&'), T_VARIABLE as field_extract_ref_var, token('.'), label() as field_extract_ref_field) as field_extract_ref,
                chain(buffer('load'), T_VARIABLE as load_var) as load,
                chain(buffer('typeof'), T_VARIABLE as typeof_var) as typeof,
                chain(buffer('sizeof'), T_VARIABLE as sizeof_var) as sizeof,
                chain(buffer('sizeof'), ctype() as sizeoftype_type) as sizeoftype,
                chain(buffer('malloc'), ctype() as malloc_type, optional(T_VARIABLE as malloc_extra)) as malloc,
                chain(buffer('realloc'), T_VARIABLE as realloc_var, T_VARIABLE as realloc_extra) as realloc,
                chain(buffer('gep'), T_VARIABLE as gep_var, T_VARIABLE as gep_offset) as gep,
                chain(llvmidentifier() as call_func, token('('), ls(T_VARIABLE as call_arg, token(',')) as call_args, token(')')) as call,
                chain(T_VARIABLE as binary_left, either(
                    token('&') as binary_and,
                    token('|') as binary_or,
                    token('^') as binary_xor,
                    token('+') as binary_add,
                    token('-') as binary_sub,
                    token('*') as binary_mul,
                    token('/') as binary_div,
                    token('%') as binary_mod,
                    token('<') as binary_smaller,
                    token(T_IS_SMALLER_OR_EQUAL) as binary_smaller_equal,
                    token('>') as binary_greater,
                    token(T_IS_GREATER_OR_EQUAL) as binary_greater_equal,
                    token(T_IS_EQUAL) as binary_equals,
                    token(T_IS_NOT_EQUAL) as binary_not_equal
                ) as binary_op, either(T_VARIABLE as binary_variable, T_LNUMBER as binary_number) as binary_right) as binary
            ), token(';')) as assignop, 
            chain(token(T_RETURN), token(';')) as returnvoid,
            chain(token(T_RETURN), T_VARIABLE as returnvalue_value, token(';')) as returnvalue,
            chain(T_VARIABLE as inc_result, token(T_INC), token(';')) as inc,
            chain(T_VARIABLE as dec_result, token(T_DEC), token(';')) as dec,
            chain(token(T_IF), token('('), T_VARIABLE as cond, token(')'), token('{'), layer() as if_stmts, token('}'), optional(chain(token(T_ELSE), token('{'), layer() as else_stmts, token('}')))) as if_stmt,
            chain(T_VARIABLE as field_deref_write_result, token(T_OBJECT_OPERATOR), T_STRING as field_deref_write_field, token('='), T_VARIABLE as field_deref_write_value, token(';')) as field_deref_write,
            chain(T_VARIABLE as const_field_assign_var, token('.'), label() as const_field_assign_field, token('='), T_LNUMBER as const_field_assign_value, token(';')) as const_field_assign,
            chain(T_VARIABLE as field_assign_var, token('.'), label() as field_assign_field, token('='), T_VARIABLE as field_assign_value, token(';')) as field_assign,
            chain(buffer('store'), T_VARIABLE as store_value, T_VARIABLE as store_pointer, token(';')) as store,
            chain(buffer('dump'), T_VARIABLE as dump_var, token(';')) as dump,
            chain(buffer('free'), T_VARIABLE as free_var, token(';')) as free,
            chain(buffer('memcpy'), T_VARIABLE as memcpy_dest, T_VARIABLE as memcpy_src, T_VARIABLE as memcpy_length, token(';')) as memcpy,
            chain(buffer('memset'), T_VARIABLE as memset_dest, T_LNUMBER as memset_value, T_VARIABLE as memset_length, token(';')) as memset,
            chain(llvmidentifier() as voidcall_func, token('('), ls(T_VARIABLE as voidcall_arg, token(',')) as voidcall_args, token(')'), token(';')) as voidcall
        )) as stmts)
    }
} >> {
    $(stmts ... {
        $$(trim {

            $(assignop ? ... {
                $(nullcheck ? ... {
                    $(result) = $this->context->builder->icmp(PHPLLVM\Builder::INT_EQ, $(nullcheck_var), $(nullcheck_var)->typeOf()->constNull());
                })

                $(constle ? ... {
                    $(result) = $this->context->builder->icmp(
                        PHPLLVM\Builder::INT_SLE,
                        $(constle_left),
                        $(constle_left)->typeOf()->constInt($(constle_right), false)
                    );
                })

                $(conststr ? ... {
                    $(result) = $this->context->builder->pointerCast(
                        $this->context->constantFromString($(conststr_value)),
                        $this->context->getTypeFromString('char*')
                    );
                })

                $(cast ? ... {
                    $type = $this->context->getTypeFromString($$(stringify($(cast_type))));
                    if (!is_object($(cast_value))) {
                        $(result) = $type->constInt($(cast_value), false);
                    } elseif ($(cast_value)->typeOf()->getWidth() >= $type->getWidth()) {
                        $(result) = $this->context->builder->truncOrBitCast($(cast_value), $type);
                    } else {
                        $(result) = $this->context->builder->zExtOrBitCast($(cast_value), $type);
                    }
                })

                $(load ? ... {
                    $(result) = $this->context->builder->load($(load_var));
                })

                $(constcast ? ... {
                    $(result) = $this->context->getTypeFromString($$(stringify($(constcast_type))))->constInt($(constcast_value), false);
                })

                $(ptrcast ? ... {
                    $(result) = $this->context->builder->pointerCast(
                        $(ptrcast_value), 
                        $this->context->getTypeFromString($$(stringify($(ptrcast_type))))
                    );
                })

                $(binary ? ... {
                    $(binary_op ... {

                        $(binary_right ... {
                            $(binary_variable ? {
                                $__right = $this->context->builder->intCast($(binary_variable), $(binary_left)->typeOf());
                            })
                            $(binary_number ? {
                                $__right = $(binary_left)->typeOf()->constInt($(binary_number), false);
                            })
                        })

                        $(binary_and ? ... {
                            $(result) = $this->context->builder->bitwiseAnd($(binary_left), $__right);
                        })

                        $(binary_or ? ... {
                            $(result) = $this->context->builder->bitwiseOr($(binary_left), $__right);
                        })

                        $(binary_xor ? ... {
                            $(result) = $this->context->builder->bitwiseXor($(binary_left), $__right);
                        })

                        $(binary_add ? ... {
                            $(unsigned ? {
                                $(result) = $this->context->builder->addNoUnsignedWrap($(binary_left), $__right);
                            })
                            $(unsigned ! {
                                $(result) = $this->context->builder->addNoSignedWrap($(binary_left), $__right);
                            })
                        })

                        $(binary_sub ? ... {
                            $(unsigned ? {
                                $(result) = $this->context->builder->subNoUnsignedWrap($(binary_left), $__right);
                            })
                            $(unsigned ! {
                                $(result) = $this->context->builder->subNoSignedWrap($(binary_left), $__right);
                            })
                        })

                        $(binary_mul ? ... {
                            $(unsigned ? {
                                $(result) = $this->context->builder->mulNoUnsignedWrap($(binary_left), $__right);
                            })
                            $(unsigned ! {
                                $(result) = $this->context->builder->mulNoSignedWrap($(binary_left), $__right);
                            })
                        })

                        $(binary_div ? ... {
                            $(unsigned ? {
                                $(result) = $this->context->builder->unsignedDiv($(binary_left), $__right);
                            })
                            $(unsigned ! {
                                $(result) = $this->context->builder->signedDiv($(binary_left), $__right);
                            })
                        })

                        $(binary_mod ? ... {
                            $(unsigned ? {
                                $(result) = $this->context->builder->unsignedRem($(binary_left), $__right);
                            })
                            $(unsigned ! {
                                $(result) = $this->context->builder->signedRem($(binary_left), $__right);
                            })
                        })

                        $(binary_smaller ? ... {
                            $(unsigned ? {
                                $cmp = PHPLLVM\Builder::INT_ULT;
                            })
                            $(unsigned ! {
                                $cmp = PHPLLVM\Builder::INT_SLT;
                            })
                            $(result) = $this->context->builder->icmp($cmp, $(binary_left), $__right);
                        })

                        $(binary_smaller_equal ? ... {
                            $(unsigned ? {
                                $cmp = PHPLLVM\Builder::INT_ULE;
                            })
                            $(unsigned ! {
                                $cmp = PHPLLVM\Builder::INT_SLE;
                            })
                            $(result) = $this->context->builder->icmp($cmp, $(binary_left), $__right);
                        })

                        $(binary_greater ? ... {
                            $(unsigned ? {
                                $cmp = PHPLLVM\Builder::INT_UGT;
                            })
                            $(unsigned ! {
                                $cmp = PHPLLVM\Builder::INT_SGT;
                            })
                            $(result) = $this->context->builder->icmp($cmp, $(binary_left), $__right);
                        })

                        $(binary_greater_equal ? ... {
                            $(unsigned ? {
                                $cmp = PHPLLVM\Builder::INT_UGE;
                            })
                            $(unsigned ! {
                                $cmp = PHPLLVM\Builder::INT_SGE;
                            })
                            $(result) = $this->context->builder->icmp($cmp, $(binary_left), $__right);
                        })

                        $(binary_equals ? ... {
                            $(result) = $this->context->builder->icmp(PHPLLVM\Builder::INT_EQ, $(binary_left), $__right);
                        })

                        $(binary_not_equal ? ... {
                            $(result) = $this->context->builder->icmp(PHPLLVM\Builder::INT_NE, $(binary_left), $__right);
                        })
                    })
                })

                $(field_extract ? ... {
                    $offset = $this->context->structFieldMap[$(field_extract_var)->typeOf()->getName()][$$(stringify($(field_extract_field)))];
                    $(result) = $this->context->builder->extractValue($(field_extract_var), $offset);
                })

                $(field_deref ? ... {
                    $offset = $this->context->structFieldMap[$(field_deref_var)->typeOf()->getElementType()->getName()][$$(stringify($(field_deref_field)))];
                    $(result) = $this->context->builder->load(
                        $this->context->builder->structGep($(field_deref_var), $offset)
                    );
                })

                $(field_extract_ref ? ... {
                    $offset = $this->context->structFieldMap[$(field_extract_ref_var)->typeOf()->getName()][$$(stringify($(field_extract_ref_field)))];
                    $(result) = $this->context->builder->gep(
                        $(field_extract_ref_var),
                        $this->context->context->int32Type()->constInt(0, false),
                        $this->context->context->int32Type()->constInt($offset, false)
                    );
                })

                $(field_deref_ref ? ... {
                    $offset = $this->context->structFieldMap[$(field_deref_ref_var)->typeOf()->getElementType()->getName()][$$(stringify($(field_deref_ref_field)))];
                    $(result) = $this->context->builder->structGep($(field_deref_ref_var), $offset);
                })

                $(sizeof ? ... {
                    if ($(sizeof_var) instanceof \PHPLLVM\Type) {
                        $type = $(sizeof_var);
                    } elseif ($(sizeof_var) instanceof \PHPLLVM\Value) {
                        $type = $(sizeof_var)->typeOf();
                    } else {
                        throw new \LogicException("Attempt to call sizeof on non-PHPLLVM type/value");
                    }
                    $(result) = $this->context->builder->ptrToInt(
                        $this->context->builder->gep(
                            $type->pointerType(0)->constNull(),
                            $this->context->context->int32Type()->constInt(1, false)
                        ),
                        $this->context->getTypeFromString('size_t')
                    );
                })

                $(typeof ? ... {
                    if ($(typeof_var) instanceof \PHPLLVM\Type) {
                        $(result) = $(typeof_var);
                    } elseif ($(typeof_var) instanceof \PHPLLVM\Value) {
                        $(result) = $(typeof_var)->typeOf();
                    } else {
                        throw new \LogicException("Attempt to call typeof on non-PHPLLVM type/value");
                    }
                })

                $(sizeoftype ? ... {
                    $type = $this->context->getTypeFromString($$(stringify($(sizeoftype_type))));
                    $(result) = $this->context->builder->ptrToInt(
                        $this->context->builder->gep(
                            $type->pointerType(0)->constNull(),
                            $this->context->context->int32Type()->constInt(1, false)
                        ),
                        $this->context->getTypeFromString('size_t')
                    );
                })

                $(gep ? ... {
                    $(result) = $this->context->builder->gep(
                        $(gep_var),
                        //$this->context->context->int32Type()->constInt(0, false),
                        //$this->context->context->int32Type()->constInt(0, false),
                        $(gep_offset)
                    );
                })

                $(malloc ? ... {
                    $type = $this->context->getTypeFromString($$(stringify($(malloc_type))));
                    $(malloc_extra ? {
                        $(result) = $this->context->memory->mallocWithExtra($type, $(malloc_extra));
                    })
                    $(malloc_extra ! {
                        $(result) = $this->context->memory->malloc($type);
                    })
                })

                $(realloc ? ... {
                    $(result) = $this->context->memory->realloc($(realloc_var), $(realloc_extra));
                })

                $(call ? ... {
                    $(result) = $this->context->builder->call(
                        $this->context->lookupFunction($$(stringify($(call_func)))) $(call_args ? {, })
                        $(call_args ... (, ) {
                            $(call_arg)
                        })
                    );
                })
            })

            $(returnvoid ? {
                $this->context->builder->returnVoid();
            })

            $(returnvalue ? ... {
                $this->context->builder->returnValue($(returnvalue_value));
            })

            $(inc ? ... {
                $(inc_result) = $this->context->builder->add($(inc_result), $(inc_result)->typeOf()->constInt(1, false));
            })

            $(dec ? ... {
                $(dec_result) = $this->context->builder->sub($(dec_result), $(dec_result)->typeOf()->constInt(1, false));
            })

            $(if_stmt ? ... {
                $bool = $this->context->castToBool($(cond));
                $prev = $this->context->builder->getInsertBlock();
                $ifBlock = $prev->insertBasicBlock('ifBlock');
                $prev->moveBefore($ifBlock);
                $(else_stmts ? { 
                    $elseBlock[] = $tmp = $ifBlock->insertBasicBlock('elseBlock');
                    $endBlock[] = $ifBlock->insertBasicBlock('endBlock');
                    $this->context->builder->branchIf($bool, $ifBlock, $tmp);
                })
                $(else_stmts ! {
                    $endBlock[] = $tmp = $ifBlock->insertBasicBlock('endBlock');
                    $this->context->builder->branchIf($bool, $ifBlock, $tmp);
                })
                $this->context->builder->positionAtEnd($ifBlock);
                $$(expand( { compile {
                    $(if_stmts)
                }}))
                if ($this->context->builder->getInsertBlock()->getTerminator() === null) {
                    $this->context->builder->branch(end($endBlock));
                }
                $(else_stmts ? {
                    $this->context->builder->positionAtEnd(array_pop($elseBlock));
                    $$(expand( { compile {
                        $(else_stmts)
                    }}))
                    if ($this->context->builder->getInsertBlock()->getTerminator() === null) {
                        $this->context->builder->branch(end($endBlock));
                    }
                })
                $this->context->builder->positionAtEnd(array_pop($endBlock));
            })

            $(field_deref_write ? ... {
                $offset = $this->context->structFieldMap[$(field_deref_write_result)->typeOf()->getElementType()->getName()][$$(stringify($(field_deref_write_field)))];
                $this->context->builder->store(
                    $(field_deref_write_value),
                    $this->context->builder->structGep($(field_deref_write_result), $offset)
                );
            })

            $(field_assign ? ... {
                $offset = $this->context->structFieldMap[$(field_assign_var)->typeOf()->getName()][$$(stringify($(field_assign_field)))];
                $this->context->builder->insertValue(
                    $(field_assign_var), 
                    $(field_assign_value),
                    $offset
                );
            })

            $(const_field_assign ? ... {
                $structType = $(const_field_assign_var)->typeOf();
                $offset = $this->context->structFieldMap[$structType->getName()][$$(stringify($(const_field_assign_field)))];

                $this->context->builder->insertValue(
                    $(const_field_assign_var), 
                    $structType->getElementAtIndex($offset)->constInt($(const_field_assign_value), false),
                    $offset
                );
            })

            $(memcpy ? ... {
                $this->context->intrinsic->memcpy($(memcpy_dest), $(memcpy_src), $(memcpy_length), false);
            })

            $(memset ? ... {
                $this->context->intrinsic->memset(
                    $(memset_dest), 
                    $this->context->context->int8Type()->constInt($(memset_value), false),
                    $(memset_length), 
                    false
                );
            })

            $(store ? ... {
                $this->context->builder->store($(store_value), $(store_pointer));
            })

            $(free ? ... {
                $this->context->memory->free($(free_var));
            })

            $(dump ? ... {
                $(dump_var)->dump();
            })

            $(voidcall ? ... {
                $this->context->builder->call(
                    $this->context->lookupFunction($$(stringify($(voidcall_func)))) $(voidcall_args ? {, })
                    $(voidcall_args ... (, ) {
                        $(voidcall_arg)
                    })
                );
            })

        })
    })
}

